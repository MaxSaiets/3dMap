# Аналіз проекту 3dMap: Логіка створення моделі

## Загальна архітектура

Проект 3dMap - це система для генерації 3D моделей з OpenStreetMap даних з інтеграцією рельєфу. Основна логіка знаходиться в бекенді (Python FastAPI), який обробляє географічні дані та створює 3D меші для 3D друку.

---

## Етапи створення моделі (покроково)

### 1. Ініціалізація та налаштування координат

**Файл:** `main.py` → `generate_model_task()`

**Крок 1.1: Визначення глобального центру**
- Якщо це частина сітки зон (hexagonal grid) - використовується вже встановлений глобальний центр
- Якщо це окрема зона - створюється новий центр на основі bbox
- **Глобальний центр** (`GlobalCenter`) - критично важливий для синхронізації координат між зонами
- Всі координати перетворюються з UTM (метри) в локальні координати відносно центру

**Крок 1.2: Створення полігону зони**
- Якщо є `zone_row` та `zone_col` - реконструюється точний шестикутник в метричному просторі
- Інакше використовуються надані координати (lat/lon → UTM → локальні)
- Полігон зони використовується для обрізання всіх мешів

**Крок 1.3: Обчислення scale_factor**
- `scale_factor = model_size_mm / reference_xy_m`
- Конвертує міліметри на моделі в метри у світі
- Використовується для всіх print-aware параметрів (висота доріг, фундаменти будівель тощо)

---

### 2. Завантаження даних OSM

**Файл:** `services/data_loader.py` → `fetch_city_data()`

**Крок 2.1: Завантаження OSM даних**
- **Будівлі** (`gdf_buildings`): полігони будівель з тегами висоти
- **Вода** (`gdf_water`): полігони річок, озер, ставків
- **Дороги** (`G_roads`): граф доріг (OSMnx) або GeoDataFrame ребер

**Крок 2.2: Перетворення координат**
- Всі дані завантажуються в UTM (метрична проекція)
- Перетворюються в локальні координати відносно глобального центру
- Це забезпечує точне вирівнювання всіх об'єктів

**Крок 2.3: Обрізання по зоні (pre-clipping)**
- **КРИТИЧНО:** Геометрії обрізаються по полігону зони ПЕРЕД створенням мешів
- Це запобігає створенню великих трикутників на краях зони
- Використовується `intersection()` з `zone_polygon_local`

---

### 3. Генерація рельєфу (Terrain)

**Файл:** `services/terrain_generator.py` → `create_terrain_mesh()`

**Крок 3.1: Створення регулярної сітки**
- Створюється сітка `resolution x resolution` точок
- Координати в локальній системі (відносно глобального центру)
- Адаптується під aspect ratio для збереження пропорцій

**Крок 3.2: Отримання висот (DEM)**
- Використовується Terrarium API або кешовані тайли
- Висоти нормалізуються з урахуванням `elevation_ref_m` та `baseline_offset_m`
- Це забезпечує синхронізацію висот між зонами

**Крок 3.3: Terrain-first операції**
- **Flatten buildings:** Вирівнювання рельєфу під будівлями (якщо `flatten_buildings_on_terrain=True`)
- **Flatten roads:** Вирівнювання під дорогами (якщо `flatten_roads_on_terrain=True`)
- **Water depression:** Вирізання западин для води в рельєфі

**Крок 3.4: Створення мешу**
- Створюється трикутна сітка з висотами
- Додається підложка (base) з товщиною `base_thickness`
- Якщо є `zone_polygon` - base та стінки формуються по формі зони
- Застосовується subdivision для плавнішого рельєфу (якщо увімкнено)

**Крок 3.5: TerrainProvider**
- Створюється `TerrainProvider` для накладання інших об'єктів на рельєф
- Зберігає оригінальні висоти для визначення рівня води під мостами

---

### 4. Обробка доріг (Roads)

**Файл:** `services/road_processor.py` → `process_roads()`

#### 4.1. Підготовка даних

**Крок 4.1.1: Буферизація доріг**
- Функція `build_road_polygons()`:
  - Для кожної дороги визначається ширина залежно від типу (`highway` тег)
  - Ширина множиться на `width_multiplier`
  - Створюються буфери навколо ліній доріг
  - Всі буфери об'єднуються через `unary_union()` для уникнення перетинів

**Ширина доріг (метри):**
```python
width_map = {
    'motorway': 12,      # Автостради
    'trunk': 10,         # Магістралі
    'primary': 8,        # Головні дороги
    'secondary': 6,      # Другорядні
    'tertiary': 5,       # Третинні
    'residential': 4,    # Житлові
    'service': 3,        # Сервісні
    'footway': 2,        # Пішохідні
    'path': 1.5          # Стежки
}
```

**Крок 4.1.2: Перетворення координат**
- Дороги перетворюються з UTM в локальні координати
- Використовується `global_center.to_local()`

**Крок 4.1.3: Обрізання по зоні**
- Дороги обрізаються по `zone_polygon_local` ПЕРЕД екструзією
- Це запобігає створенню "завіс" (великих вертикальних листів) на краях

#### 4.2. Визначення мостів

**Файл:** `services/road_processor.py` → `detect_bridges()`

**Крок 4.2.1: Перевірка тегів OSM**
- Перевіряється тег `bridge=yes`
- Перевіряється `layer` (позитивний layer = естакада/віадук)
- Визначається висота моста залежно від типу:
  - Suspension: 5.0м
  - Arch: 4.0м
  - Beam: 3.0м
  - Default: 2.5м

**Крок 4.2.2: Перевірка перетину з водою**
- Якщо дорога перетинає водний об'єкт - це міст
- Висота залежить від ширини води:
  - Велика річка (>50м): 4.0м
  - Середня (20-50м): 3.0м
  - Мала (<20м): 2.0м

**Крок 4.2.3: Створення bridge areas**
- Для кожного моста створюється буферована область (12м за замовчуванням)
- Це використовується для розділення мостів та звичайних доріг

#### 4.3. Створення 3D мешів доріг

**Крок 4.3.1: Розділення на частини**
- Кожен полігон доріг перевіряється на перетин з bridge areas
- Створюються окремі частини:
  - **Bridge parts:** Дороги, що перетинають bridge areas
  - **Normal parts:** Решта доріг

**Крок 4.3.2: Екструзія полігонів**
- Використовується `trimesh.creation.extrude_polygon()`
- Висота: `road_height` (конвертована з мм в метри через `scale_factor`)
- Автоматично обробляються дірки (holes) та складні геометрії

**Крок 4.3.3: Накладання на рельєф**

**Для звичайних доріг:**
```python
# Отримуємо висоти рельєфу для кожної вершини
ground_z_values = terrain_provider.get_surface_heights_for_points(vertices[:, :2])

# Адаптивне втискання (embed) залежно від нахилу
adaptive_embed = road_embed
if slope > road_embed * 2.0:
    adaptive_embed = road_embed * (1.0 - min(0.5, (slope - road_embed * 2.0) / (slope + 1.0)))

# Накладаємо дорогу на рельєф
road_z = ground_z_values + old_z - adaptive_embed
```

**Для мостів:**
```python
# Визначаємо рівень води під мостом
water_level = median(original_ground_z - 0.2)

# Мінімальний clearance над водою
min_clearance = max(bridge_height_offset, road_height * 2.0)

# Висота моста над водою або землею
bridge_base_z = max(
    water_level + min_clearance,
    ground_z + bridge_height_offset
)

# Ramp (плавний підйом/спуск) на краях моста
ramp_t = compute_ramp_factor(position_along_bridge)
base = base_nonbridge * (1.0 - ramp_t) + bridge_base_z * ramp_t
```

**Крок 4.3.4: Створення опор мостів**
- Функція `create_bridge_supports()`:
  - Розміщує опори по краях моста (для стабільності)
  - Додає центральні опори для довгих мостів (>40м)
  - Опори йдуть від моста до землі/води
  - Ширина опори: 2м, відстань між опорами: 20м

**Крок 4.3.5: Об'єднання мешів**
- Всі меші доріг об'єднуються через `trimesh.util.concatenate()`
- Покращення якості для 3D друку:
  - `fix_normals()` - виправлення нормалей
  - `remove_duplicate_faces()` - видалення дублікатів
  - `fill_holes()` - заповнення дірок
  - `merge_vertices()` - об'єднання вершин

**Крок 4.3.6: Кольори**
- Звичайні дороги: темно-сірий `[40, 40, 40, 255]`
- Мости: сірий `[60, 60, 60, 255]`
- Опори мостів: сірий `[120, 120, 120, 255]`

---

### 5. Обробка зелених зон (Green Areas / Parks)

**Файл:** `services/green_processor.py` → `process_green_areas()`

#### 5.1. Підготовка даних

**Крок 5.1.1: Завантаження даних**
- Дані завантажуються через `fetch_extras()` (парки, ліси, газони)
- Геометрії в UTM (метри)

**Крок 5.1.2: Перетворення координат**
- Перетворюються з UTM в локальні координати
- Використовується `global_center.to_local()`

**Крок 5.1.3: Обрізання по зоні**
- **КРИТИЧНО:** Парки обрізаються по `zone_polygon_local` ПЕРЕД екструзією
- Видаляються артефакти менше 10м²

#### 5.2. Очищення та фільтрація

**Крок 5.2.1: Валідація геометрій**
- Виправлення невалідних полігонів через `buffer(0)`
- Розбиття MultiPolygon на окремі Polygon

**Крок 5.2.2: Об'єднання (Union)**
- Всі полігони об'єднуються через `unary_union()`
- Це зменшує шви та видаляє дрібні артефакти від обрізання

**Крок 5.2.3: Фільтрація за площею**
- Видаляються полігони менше 100м²

**Крок 5.2.4: Фільтрація за шириною (print-aware)**
- Якщо `scale_factor` відомий, обчислюється мінімальна ширина на моделі
- Використовується `minimum_rotated_rectangle` для визначення ширини
- Видаляються "тонкі смуги" (slivers), які не будуть видимі на моделі

**Крок 5.2.5: Спрощення (Simplify)**
- Застосовується `simplify()` з tolerance залежно від масштабу
- `simplify_tol_m = simplify_mm / scale_factor`
- Зберігає топологію (`preserve_topology=True`)

#### 5.3. Створення 3D мешів

**Крок 5.3.1: Екструзія полігонів**
```python
mesh = trimesh.creation.extrude_polygon(poly, height=height_m)
```
- Створюється вертикальний меш з висотою `height_m`
- Висота конвертується з мм в метри: `height_m = parks_height_mm / scale_factor`

**Крок 5.3.2: Накладання на рельєф (точкове)**

**ВАЖЛИВО:** Використовується **точкове накладання** - висота рельєфу отримується для КОЖНОЇ вершини:

```python
# Отримуємо висоти рельєфу для КОЖНОЇ вершини
ground_heights = terrain_provider.get_surface_heights_for_points(v[:, :2])

# Нормалізуємо old_z до відносної висоти [0, 1]
relative_height = (old_z - z_min) / (z_max - z_min)

# Розраховуємо нові Z координати:
# - Нижні вершини: ground - embed_m
# - Верхні вершини: ground - embed_m + height_m
new_z = ground_heights - embed_m + relative_height * height_m
```

**Крок 5.3.3: Захист від провалювання**
- Перевіряється, чи жодна вершина не провалилась нижче рельєфу
- Додається safety margin (1см)
- Якщо потрібно - всі вершини піднімаються на однакову висоту

**Крок 5.3.4: Додавання фасетованої текстури**

Функція `_add_strong_faceted_texture()`:

1. **Subdivision:**
   - Меш ділиться 2 рази для створення більшої кількості вершин
   - Це створює більше трикутників для текстури

2. **Визначення верхніх вершин:**
   - Вершини вище 80% висоти мешу вважаються "верхніми"

3. **Випадковий шум:**
   ```python
   texture_amplitude = (height_m * 0.5) / scale_factor  # 50% від висоти
   noise = (random - 0.5) * texture_amplitude * 2.0
   mesh.vertices[top_indices, 2] += noise
   ```

4. **Хвильова компонента:**
   ```python
   wave_pattern = (
       sin(x / 3.0) * cos(y / 3.0) * 0.3 +      # Дрібні хвилі
       sin((x + y) / 8.0) * 0.2 +                # Середні хвилі
       sin(x / 15.0) * sin(y / 15.0) * 0.1        # Великі хвилі
   ) * texture_amplitude
   ```
   - Створює структуровану, природну текстуру замість хаотичного шуму

**Результат:** Нерівна, фасетована поверхня, що виглядає як низькополігональна структурована текстура

#### 5.4. Об'єднання мешів

- Всі меші парків об'єднуються через `trimesh.util.concatenate()`
- Якщо об'єднання не вдалося - повертається перший меш

---

### 6. Обробка будівель

**Файл:** `services/building_processor.py` → `process_buildings()`

**Основні кроки:**
1. Екструзія полігонів на висоту з OSM тегів
2. Накладання на рельєф з фундаментом
3. Адаптивна глибина фундаменту залежно від нахилу
4. Об'єднання мешів

---

### 7. Обробка води

**Файл:** `services/water_processor.py`

**Два підходи:**

**7.1. Terrain-first (якщо `terrain_enabled=True`):**
- Вода вирізається в рельєфі як depression (западина)
- Створюється тонка поверхня для візуалізації
- Товщина поверхні: 0.2-0.6мм на моделі

**7.2. Mesh-based (якщо `terrain_enabled=False`):**
- Створюється меш води з глибиною
- Використовується булеве віднімання для западин

---

### 8. Покращення якості мешів

**Файл:** `services/mesh_quality.py`

**Для всіх мешів:**
- `improve_mesh_for_3d_printing()`:
  - Виправлення нормалей
  - Видалення дублікатів
  - Заповнення дірок
  - Об'єднання вершин
  - Валідація для 3D друку

---

### 9. Обрізання мешів по зоні

**Файл:** `services/mesh_clipper.py`

**Крок 9.1: Перевірка pre-clipping**
- Якщо геометрії вже обрізані по зоні ПЕРЕД створенням мешів - mesh-level clipping не потрібен
- Mesh-level clipping може створити артефакти (великі трикутники на краях)

**Крок 9.2: Обрізання (якщо потрібно)**
- Якщо є `zone_polygon_coords` - обрізання по полігону
- Інакше - обрізання по bbox з tolerance 0.1м

---

### 10. Експорт моделі

**Файл:** `services/model_exporter.py` → `export_scene()`

**Крок 10.1: Масштабування**
- Всі координати масштабуються до `model_size_mm`
- Використовується `reference_xy_m` для стабільного масштабу між зонами

**Крок 10.2: Експорт у формат**
- **STL:** Бінарний формат для 3D друку
- **3MF:** XML-формат з підтримкою кольорів та метаданих

**Крок 10.3: Preview частини**
- Експортуються окремі STL файли для кольорового прев'ю:
  - `base.stl` - рельєф
  - `roads.stl` - дороги
  - `buildings.stl` - будівлі
  - `water.stl` - вода
  - `parks.stl` - парки
  - `poi.stl` - POI

---

## Ключові особливості обробки доріг

### 1. Фізична ширина доріг
- Ширина залежить від типу дороги (motorway, primary, residential тощо)
- Множник `width_multiplier` дозволяє масштабувати ширину
- Мінімальна ширина для друку: 1мм на моделі

### 2. Об'єднання на перехрестях
- `unary_union()` об'єднує всі буфери доріг
- Це запобігає створенню "сходинок" на перехрестях
- Дороги плавно з'єднуються

### 3. Накладання на рельєф
- Адаптивне втискання (`adaptive_embed`) залежно від нахилу
- На крутих схилах дорога менше втискається, щоб не "висіла"
- Мінімальний clearance для верхніх вершин (2% висоти)

### 4. Мости
- Автоматичне визначення мостів (теги OSM + перетин з водою)
- Підйом мостів над водою/землею
- Плавні ramps на краях мостів
- Опори для стабільності при друку

### 5. Pre-clipping
- Дороги обрізаються по зоні ПЕРЕД екструзією
- Це запобігає створенню "завіс" на краях зони

---

## Ключові особливості обробки зелених зон

### 1. Точкове накладання на рельєф
- **КРИТИЧНО:** Висота рельєфу отримується для КОЖНОЇ вершини мешу
- Це забезпечує точне накладання на рельєф без провалювання
- Нормалізація відносної висоти для збереження форми

### 2. Фасетована текстура
- **Subdivision:** 2 рівні для більшої кількості вершин
- **Випадковий шум:** ±100% амплітуди для фасетованого вигляду
- **Хвильова компонента:** Комбінація хвиль різних частот для природної структури
- Результат: нерівна, структурована поверхня (як на фото)

### 3. Print-aware фільтрація
- Мінімальна ширина на моделі: 0.8мм (за замовчуванням)
- Спрощення з tolerance залежно від масштабу
- Видалення тонких смуг (slivers), які не будуть видимі

### 4. Об'єднання полігонів
- `unary_union()` зменшує шви та артефакти
- Видаляє дрібні slivers, створені обрізанням

### 5. Pre-clipping
- Парки обрізаються по зоні ПЕРЕД екструзією
- Видаляються артефакти менше 10м²

---

## Синхронізація між зонами (Hexagonal Grid)

### 1. Глобальний центр
- Всі зони використовують один глобальний центр
- Координати відносні до цього центру
- Забезпечує ідеальне стикування зон

### 2. Глобальний elevation_ref
- Обчислюється для всієї сітки один раз
- Всі зони використовують одну базову висоту
- Забезпечує синхронізацію висот між зонами

### 3. Reference XY
- `reference_xy_m` обчислюється з полігону зони
- Використовується для стабільного масштабування
- Забезпечує однаковий масштаб між зонами

### 4. Preserve global XY
- Якщо `preserve_global_xy=True` - координати не центруються
- Забезпечує ідеальне стикування при експорті

---

## Висновки

### Сильні сторони:
1. ✅ **Terrain-first підхід:** Рельєф створюється першим, інші об'єкти накладаються на нього
2. ✅ **Pre-clipping:** Геометрії обрізаються ПЕРЕД створенням мешів, що запобігає артефактам
3. ✅ **Print-aware параметри:** Всі розміри конвертуються з мм на моделі в метри у світі
4. ✅ **Синхронізація зон:** Глобальний центр та elevation_ref забезпечують ідеальне стикування
5. ✅ **Якість мешів:** Покращення для 3D друку (нормалі, дірки, дублікати)

### Особливості обробки доріг:
- Фізична ширина залежно від типу
- Об'єднання на перехрестях
- Адаптивне накладання на рельєф
- Автоматичне визначення мостів
- Опори для мостів

### Особливості обробки зелених зон:
- Точкове накладання на рельєф (кожна вершина)
- Фасетована текстура (subdivision + шум + хвилі)
- Print-aware фільтрація
- Об'єднання для зменшення швів

### Потенційні покращення:
1. Оптимізація продуктивності (паралельна обробка)
2. Кешування проміжних результатів
3. Покращення алгоритму фасетованої текстури
4. Додаткові типи об'єктів (POI, транспорт)

---

## Діаграма потоку даних

```
[OSM Data] → [Data Loader] → [UTM Coords]
                                      ↓
[Global Center] → [Local Coords] → [Pre-clip to Zone]
                                      ↓
[Terrain Generator] → [Terrain Mesh + TerrainProvider]
                                      ↓
[Road Processor] → [Road Meshes] ────┐
                                      ├──→ [Model Exporter]
[Green Processor] → [Parks Meshes] ──┤
                                      │
[Building Processor] → [Building Meshes] ──┤
                                      │
[Water Processor] → [Water Mesh] ────┘
                                      ↓
                              [STL/3MF Export]
```

---

*Документ створено на основі аналізу коду проекту 3dMap*

