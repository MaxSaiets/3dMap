# Синхронізація висот між зонами гексагональної сітки

## Проблема

Коли генерувалися моделі для різних зон гексагональної сітки, кожна зона використовувала свою власну нормалізацію висот:

1. **Локальна нормалізація** - кожна зона нормалізувала висоти відносно свого локального мінімуму
2. **Різні базові висоти** - кожна зона мала різну базову висоту (0 або baseline_offset)
3. **Різні висоти підложки** - base створювався від локального мінімуму кожної зони
4. **Невідповідності на стиках** - зони не стикувалися ідеально через різні базові висоти

## Рішення

### 1. Глобальний elevation_ref_m

**Файл:** `services/elevation_sync.py` → `calculate_global_elevation_reference()`

**Логіка:**
```python
# Збираємо координати з усіх зон
grid_bbox_latlon = (north, south, east, west)  # Bbox всієї сітки

# Створюємо регулярну сітку точок для семплінгу висот
# Використовуємо адаптивну кількість точок (5-50 точок)
grid_size = int(np.ceil(np.sqrt(total_zones * sample_points_per_zone)))

# Отримуємо абсолютні висоти для всієї сітки
Z_abs = get_elevation_abs_meters_from_api(...)

# Знаходимо мінімальну висоту з усіх зон
elevation_ref_m = np.nanmin(Z_abs)  # Глобальна базова висота
```

**Ключові моменти:**
- Обчислюється **ОДИН РАЗ** для всієї сітки
- Використовує **мінімальну висоту** з усіх зон як базову
- Всі зони використовують **один і той самий** elevation_ref_m

### 2. Використання глобального elevation_ref_m

**Файл:** `services/terrain_generator.py` → `get_elevation_data()`

**Логіка:**
```python
# Якщо elevation_ref_m задано - використовуємо глобальну нормалізацію
if elevation_ref_m is not None:
    Z_rel = (Z_abs - elevation_ref_m) * z_scale
else:
    # Fallback: локальна нормалізація
    zmin = np.nanmin(Z_abs)
    Z_rel = (Z_abs - zmin) * z_scale

# Додаємо baseline_offset_m для мінімальної висоти на моделі
Z_rel = Z_rel + baseline_offset_m
```

**Результат:**
- Всі зони мають **однакову базову висоту** (0 + baseline_offset_m)
- Мінімальна висота в кожній зоні = baseline_offset_m
- Максимальна висота залежить від рельєфу, але базова висота однакова

### 3. Оптимальна товщина підложки

**Файл:** `services/elevation_sync.py` → `calculate_optimal_base_thickness()`

**Логіка:**
```python
if elevation_ref_m is not None:
    # Всі зони синхронізовані - використовуємо мінімальну товщину
    optimal_thickness = min_base_thickness_mm  # 1.0мм за замовчуванням
    
    # Для великої кількості зон (>10) трохи збільшуємо для стабільності
    if len(zones) > 10:
        optimal_thickness = min(min_base_thickness_mm * 1.1, max_base_thickness_mm)
else:
    # Немає синхронізації - використовуємо більшу товщину для компенсації
    optimal_thickness = min_base_thickness_mm * 1.3
```

**Адаптація:**
- До розміру моделі: для великих моделей (>200мм) трохи збільшуємо
- До кількості зон: для багатьох зон (>20) використовуємо мінімальну товщину

### 4. Покращена логіка створення base

**Файл:** `services/terrain_generator.py` → `create_solid_terrain()`

**Логіка:**
```python
# Знаходимо мінімальну висоту з heightfield
terrain_min_z = float(np.min(Z))

# Мінімізуємо base_thickness для синхронізації зон
min_base_thickness = 0.5  # Мінімум 0.5м для стабільності
effective_base_thickness = max(float(base_thickness), min_base_thickness)

# Для плоского рельєфу зменшуємо товщину
z_range = float(np.max(Z) - np.min(Z))
if z_range < 5.0:  # Дуже плоский рельєф
    effective_base_thickness = max(effective_base_thickness * 0.7, min_base_thickness)

min_z = terrain_min_z - effective_base_thickness
```

**Ключові моменти:**
- Використовує мінімальну висоту з heightfield (Z масив)
- Мінімізує base_thickness для кращого стикування
- Адаптує товщину до рельєфу (для плоского рельєфу - менша товщина)

## Як це працює

### Потік даних:

```
1. Користувач вибирає зони на фронтенді
   ↓
2. Backend (generate_zones_endpoint):
   a. Визначає глобальний центр сітки
   b. Обчислює глобальний elevation_ref_m (мінімальна висота з усіх зон)
   c. Обчислює оптимальну товщину підложки
   d. Встановлює глобальний центр та передає параметри до кожної зони
   ↓
3. Для кожної зони (generate_model_task):
   a. Використовує глобальний центр (вже встановлений)
   b. Використовує глобальний elevation_ref_m для нормалізації висот
   c. Використовує оптимальну товщину підложки
   d. Створює модель з правильними висотами
   ↓
4. Всі зони мають:
   - Однакову базову висоту (elevation_ref_m)
   - Однакову мінімальну висоту (baseline_offset_m)
   - Мінімальну товщину підложки
   → Зони ідеально стикуються!
```

## Формула нормалізації висот

### З глобальним elevation_ref_m:
```
Z_rel = (Z_abs - elevation_ref_m) * z_scale + baseline_offset_m
```

**Приклад:**
```
Глобальний elevation_ref_m = 150м (мінімальна висота з усіх зон)

Зона 1:
  Z_abs = [150м, 160м, 170м]
  Z_rel = [0м, 10м, 20м] * 1.5 + 0 = [0м, 15м, 30м]

Зона 2:
  Z_abs = [152м, 162м, 172м]
  Z_rel = [2м, 12м, 22м] * 1.5 + 0 = [3м, 18м, 33м]

Результат:
  - Зона 1: мінімум = 0м, максимум = 30м
  - Зона 2: мінімум = 3м, максимум = 33м
  - Базові висоти різні, але відносні висоти правильні
```

**ВАЖЛИВО:** Для ідеального стикування потрібно, щоб мінімальні висоти були однакові. Це забезпечується через:
1. Використання глобального elevation_ref_m (мінімальна висота з усіх зон)
2. baseline_offset_m = 0 (або однаковий для всіх зон)

### Без глобального elevation_ref_m (fallback):
```
Z_rel = (Z_abs - zmin_local) * z_scale + baseline_offset_m
```

**Проблема:** Кожна зона має свій zmin_local, тому базові висоти різні.

## Оптимізація підложки

### Мінімізація товщини

**Для синхронізованих зон:**
- Мінімальна товщина: 1.0мм (за замовчуванням)
- Для багатьох зон (>20): 1.05мм
- Для великих моделей (>200мм): 1.15мм

**Для несинхронізованих зон:**
- Товщина: 1.3мм (для компенсації різниць)

### Адаптація до рельєфу

**Для плоского рельєфу (< 5м перепад):**
- Зменшуємо товщину на 30% (0.7 * base_thickness)
- Мінімум: 0.5м в світових одиницях

**Для крутого рельєфу (> 50м перепад):**
- Використовуємо стандартну товщину
- Мінімум: 0.5м в світових одиницях

## Переваги рішення

1. **Ідеальне стикування:** Всі зони мають однакову базову висоту
2. **Мінімальна підложка:** Товщина оптимізована для стабільності без зайвих об'ємів
3. **Правильні висоти:** Висоти визначаються відносно глобального elevation_ref_m
4. **Масштабування:** Моделі можна об'єднати без додаткових трансформацій
5. **Адаптивність:** Товщина підложки адаптується до рельєфу та кількості зон

## Технічні деталі

### Обчислення elevation_ref_m

**Крок 1: Збір координат**
- Збираємо координати з усіх зон
- Обчислюємо bbox для всієї сітки

**Крок 2: Створення сітки для семплінгу**
- Адаптивна кількість точок: `sqrt(total_zones * sample_points_per_zone)`
- Мінімум: 5 точок, максимум: 50 точок
- Для великих сіток (>20 зон) зменшуємо кількість точок

**Крок 3: Отримання висот**
- Використовуємо `get_elevation_abs_meters_from_api()` для отримання абсолютних висот
- Конвертуємо координати через глобальний центр (якщо доступний)

**Крок 4: Обчислення elevation_ref_m**
- `elevation_ref_m = np.nanmin(Z_abs)` - мінімальна висота з усіх зон
- Це забезпечує, що всі зони мають однакову базову висоту

### Передача параметрів

**В generate_zones_endpoint:**
```python
# Обчислюємо глобальні параметри
global_elevation_ref_m, global_baseline_offset_m = calculate_global_elevation_reference(...)
optimal_base_thickness_mm = calculate_optimal_base_thickness(...)

# Передаємо до кожної зони
zone_request = GenerationRequest(
    ...
    elevation_ref_m=global_elevation_ref_m,
    baseline_offset_m=global_baseline_offset_m,
    terrain_base_thickness_mm=optimal_base_thickness_mm,
)
```

**В generate_model_task:**
```python
# Отримуємо параметри з request
elevation_ref_m = getattr(request, 'elevation_ref_m', None)
baseline_offset_m = getattr(request, 'baseline_offset_m', 0.0)

# Передаємо до create_terrain_mesh
terrain_mesh, terrain_provider = create_terrain_mesh(
    ...
    elevation_ref_m=elevation_ref_m,
    baseline_offset_m=baseline_offset_m,
    ...
)
```

## Діагностика

### Перевірка правильності роботи

**Логи:**
```
[INFO] Обчислення глобального elevation_ref для 5 зон...
[INFO] Grid bbox: north=50.500000, south=50.400000, east=30.600000, west=30.400000
[INFO] Глобальний elevation_ref: min=150.23м, max=180.45м, mean=165.34м
[INFO] Глобальний elevation_ref_m: 150.23м (висота над рівнем моря)
[INFO] Глобальний baseline_offset_m: 0.000м
[INFO] Оптимальна товщина підложки: 1.00мм (зони: 5, модель: 100мм, elevation_ref: є)
[INFO] Фінальна товщина підложки: 1.00мм (оптимальна: 1.00мм, користувацька: 2.00мм)
[INFO] Використовується глобальний elevation_ref_m: 150.23м для синхронізації висот
```

**Якщо бачите:**
- `"Глобальний elevation_ref_m: X.XXм"` - ✅ Правильно
- `"Використовується глобальний elevation_ref_m"` - ✅ Правильно
- `"elevation_ref_m не задано"` - ⚠️ Можлива проблема (для сітки зон)

### Перевірка висот

**Для кожної зони:**
```
[DEBUG] Elevation data shape check: Z=(100, 100), Grid X=(100, 100), Grid Y=(100, 100)
[OK] Elevation data matches grid: Z=(100, 100), Grid=(100, 100)
```

**Висоти мають бути нормалізовані відносно elevation_ref_m:**
- Мінімальна висота ≈ baseline_offset_m (зазвичай 0)
- Максимальна висота залежить від рельєфу та z_scale

## Відомі обмеження

1. **Залежність від API** - якщо API недоступний, використовується локальна нормалізація
2. **Час обчислення** - для великих сіток (>50 зон) обчислення elevation_ref_m може зайняти час
3. **Точність** - використовується розріджена сітка для семплінгу (5-50 точок)

## Майбутні покращення

1. **Кешування elevation_ref_m** - зберігати для повторного використання
2. **Паралельне обчислення** - обчислювати висоти для кількох зон одночасно
3. **Адаптивний семплінг** - більше точок для складного рельєфу
4. **Валідація стикування** - автоматична перевірка, що зони стикуються

