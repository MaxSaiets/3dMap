# Синхронізація глобального центру для гексагональної сітки

## Проблема

Коли створюється гексагональна сітка і вибираються зони для генерації моделей, кожна зона оброблялася окремо і створювала свій власний глобальний центр на основі bbox цієї зони. Це призводило до того, що:

1. **Кожна зона мала різну точку відліку (0,0)**
2. **Зони не підходили одна до одної** - були невідповідності на стиках
3. **Висоти рельєфу визначалися відносно різних центрів** - це спричиняло "сходи" між зонами

## Рішення

### 1. Визначення глобального центру для всієї сітки

**Файл:** `main.py` → `generate_zones_endpoint()`

**Логіка:**
```python
# Збираємо всі координати з усіх зон
all_lons = []
all_lats = []

for zone in request.zones:
    # Отримуємо координати з кожної зони
    all_lons.extend(zone_lons)
    all_lats.extend(zone_lats)

# Обчислюємо bbox для ВСІЄЇ сітки
grid_bbox = {
    'north': max(all_lats),
    'south': min(all_lats),
    'east': max(all_lons),
    'west': min(all_lons)
}

# Визначаємо центр ВСІЄЇ сітки
grid_center_lat = (grid_bbox['north'] + grid_bbox['south']) / 2.0
grid_center_lon = (grid_bbox['east'] + grid_bbox['west']) / 2.0

# Встановлюємо глобальний центр ОДИН РАЗ для всієї сітки
global_center = set_global_center(grid_center_lat, grid_center_lon)
```

**Ключові моменти:**
- Центр обчислюється на основі **всіх зон**, а не окремої зони
- Центр встановлюється **ОДИН РАЗ** перед генерацією всіх зон
- Всі зони використовують **один і той самий** глобальний центр

### 2. Використання встановленого центру в генерації

**Файл:** `main.py` → `generate_model_task()`

**Логіка:**
```python
# Перевіряємо, чи вже є встановлений глобальний центр (для сітки зон)
existing_global_center = get_global_center()
if existing_global_center is not None:
    global_center = existing_global_center
    print(f"[INFO] Використовується ВЖЕ ВСТАНОВЛЕНИЙ глобальний центр (для сітки)")
else:
    # Якщо немає встановленого центру, створюємо новий для цієї зони
    global_center = get_or_create_global_center(bbox_latlon=latlon_bbox)
    print(f"[INFO] Створено новий глобальний центр для зони")
```

**Ключові моменти:**
- Спочатку перевіряємо, чи вже є встановлений глобальний центр
- Якщо є - використовуємо його (для сітки зон)
- Якщо немає - створюємо новий (для одиночної зони)

### 3. Функція для обчислення центру сітки

**Файл:** `hexagonal_grid.py` → `calculate_grid_center_from_geojson()`

**Призначення:**
- Обчислює оптимальний центр для всієї сітки на основі GeoJSON features
- Може бути використана для попереднього обчислення центру перед генерацією зон

## Як це працює

### Потік даних:

```
1. Користувач вибирає зони на фронтенді
   ↓
2. Frontend відправляє запит /api/generate-zones зі списком зон
   ↓
3. Backend (generate_zones_endpoint):
   a. Збирає всі координати з усіх зон
   b. Обчислює bbox для всієї сітки
   c. Визначає центр сітки (lat, lon)
   d. Встановлює глобальний центр ОДИН РАЗ: set_global_center()
   ↓
4. Для кожної зони:
   a. Створює GenerationRequest
   b. Запускає generate_model_task в фоні
   ↓
5. generate_model_task для кожної зони:
   a. Перевіряє чи є встановлений глобальний центр
   b. Використовує встановлений центр (не створює новий!)
   c. Конвертує координати: UTM → локальні (відносно центру)
   d. Генерує модель з правильними координатами
   ↓
6. Всі зони мають однакову точку відліку (0,0)
   → Зони ідеально підходять одна до одної!
```

## Переваги рішення

1. **Синхронізація координат:** Всі зони використовують одну точку відліку
2. **Ідеальне накладання:** Зони підходять одна до одної без невідповідностей
3. **Правильні висоти:** Висоти рельєфу визначаються відносно одного центру
4. **Масштабування:** Моделі можна об'єднати без додаткових трансформацій
5. **Зворотна сумісність:** Одиночні зони все ще працюють (створюють свій центр)

## Технічні деталі

### Глобальний центр (GlobalCenter)

**Клас:** `services/global_center.py`

**Функції:**
- `set_global_center(lat, lon)` - встановлює глобальний центр
- `get_global_center()` - отримує встановлений центр (або None)
- `get_or_create_global_center(bbox_latlon)` - отримує або створює новий

**Перетворення координат:**
- `to_utm(lon, lat)` - WGS84 → UTM метри
- `to_wgs84(x, y)` - UTM метри → WGS84
- `to_local(x_utm, y_utm)` - UTM → локальні (відносно центру)
- `from_local(x_local, y_local)` - локальні → UTM

### Локальні координати

**Призначення:**
- Всі об'єкти (рельєф, будівлі, дороги, вода) використовують локальні координати
- Локальні координати відносні до глобального центру (0,0)
- Це забезпечує синхронізацію між зонами

**Приклад:**
```
Глобальний центр: lat=50.45, lon=30.52 (Київ)

Зона 1 (центр: 50.46, 30.53):
  UTM: (500000, 5600000)
  Локальні: (1000, 2000)  ← відносно центру

Зона 2 (центр: 50.44, 30.51):
  UTM: (498000, 5598000)
  Локальні: (-1000, -2000)  ← відносно ТОГО Ж центру
```

## Приклад використання

### 1. Генерація сітки

```python
# Frontend відправляє запит
POST /api/hexagonal-grid
{
  "north": 50.5,
  "south": 50.4,
  "east": 30.6,
  "west": 30.4,
  "hex_size_m": 500.0
}

# Backend генерує сітку та повертає GeoJSON
```

### 2. Генерація зон

```python
# Frontend відправляє запит з вибраними зонами
POST /api/generate-zones
{
  "zones": [
    {"id": "hex_0_0", "geometry": {...}},
    {"id": "hex_0_1", "geometry": {...}},
    {"id": "hex_1_0", "geometry": {...}}
  ],
  "model_size_mm": 100.0,
  ...
}

# Backend:
# 1. Обчислює центр всієї сітки
# 2. Встановлює глобальний центр ОДИН РАЗ
# 3. Генерує модель для кожної зони з одним центром
```

### 3. Результат

- Всі зони мають однакову точку відліку (0,0)
- Зони ідеально підходять одна до одної
- Моделі можна об'єднати без додаткових трансформацій

## Діагностика

### Перевірка правильності роботи

**Логи:**
```
[INFO] Визначення глобального центру для всієї сітки (3 зон)...
[INFO] Глобальний центр сітки: lat=50.450000, lon=30.520000
[INFO] Глобальний центр встановлено: lat=50.450000, lon=30.520000, UTM zone=36
[INFO] Використовується ВЖЕ ВСТАНОВЛЕНИЙ глобальний центр (для сітки)
```

**Якщо бачите:**
- `"Використовується ВЖЕ ВСТАНОВЛЕНИЙ глобальний центр"` - ✅ Правильно
- `"Створено новий глобальний центр для зони"` - ⚠️ Можлива проблема (для сітки зон)

### Перевірка координат

**Для кожної зони:**
```
[DEBUG] Bbox для зони (локальні координати): (-500.0, -500.0, 500.0, 500.0)
```

**Всі зони мають використовувати локальні координати відносно одного центру.**

## Відомі обмеження

1. **Глобальний центр зберігається в пам'яті** - при перезапуску сервера втрачається
2. **Одна сітка за раз** - якщо генерувати дві різні сітки одночасно, можуть бути конфлікти
3. **UTM зона** - визначається автоматично на основі центру (може бути проблема на межах зон)

## Майбутні покращення

1. **Збереження центру в БД** - для постійного зберігання
2. **Підтримка множинних сіток** - через контекст менеджер
3. **Валідація UTM зони** - перевірка що всі зони в одній зоні
4. **Візуалізація центру** - показувати центр на карті

