# Виправлення обробки зелених зон (Green Processor)

## Виявлені проблеми

### 1. КРИТИЧНА ПОМИЛКА: Розрахунок амплітуди текстури

**Місце:** `_add_strong_faceted_texture()`, рядок 310 (старий код)

**Проблемний код:**
```python
texture_amplitude = max(0.15, (height_m * 0.5) / float(scale_factor))
```

**Проблема:**
- `scale_factor` для 3D друку - це дуже мале число (наприклад, 1:1000 → 0.001)
- Якщо `height_m = 1 метр`, а `scale_factor = 0.001`, то результат: `1 × 0.5 / 0.001 = 500 метрів!`
- Це створювало величезні "шипи" або "стіни" на краях зелених зон

**Виправлення:**
```python
target_noise_mm = 0.25  # Бажана висота шуму на роздруківці (0.25мм)
texture_amplitude = target_noise_mm / float(scale_factor)
texture_amplitude = min(texture_amplitude, 2.0)  # Максимум 2 метри
```

**Логіка:**
- Визначаємо бажану висоту нерівності на моделі (0.25мм)
- Конвертуємо в метри світу: `target_noise_m = target_noise_mm / scale_factor`
- Обмежуємо максимальну амплітуду для безпеки

---

### 2. ПОМИЛКА ЛОГІКИ: "Літаючий килим"

**Місце:** `process_green_areas()`, рядки 227-234 (старий код)

**Проблемний код:**
```python
below_ground = new_z < min_allowed_z
if np.any(below_ground):
    needed_lift = min_allowed_z[below_ground] - new_z[below_ground]
    max_lift = float(np.max(needed_lift))
    if max_lift > 0:
        # Піднімаємо ВСІ вершини на однакову висоту
        new_z += max_lift
```

**Проблема:**
- Якщо хоча б одна вершина великого парку провалюється під землю (наприклад, у яру), весь парк піднімається на цю висоту
- Результат: парк відривається від землі на пагорбах і "висить у повітрі"

**Виправлення:**
```python
# Використовуємо np.maximum для локальної корекції
# Тільки ті вершини, що провалились, виштовхуються до рівня землі
new_z = np.maximum(new_z, min_allowed_z)
```

**Логіка:**
- `np.maximum()` застосовується поелементно
- Кожна вершина, що провалилась, виштовхується до мінімально дозволеного рівня
- Інші вершини залишаються на місці
- Парк не "літає", а плавно слідує за рельєфом

---

### 3. Неефективність: Подвійний Subdivide

**Місце:** `_add_strong_faceted_texture()`, рядки 282-283 (старий код)

**Проблемний код:**
```python
for _ in range(2):
    mesh = mesh.subdivide()
```

**Проблема:**
- Для великих GIS-полігонів подвійний subdivision може створити мільйони трикутників
- Це призводить до зависання або вильоту по пам'яті

**Виправлення:**
```python
# Обмежуємо subdivision залежно від розміру мешу
if len(mesh.vertices) < 10000:
    try:
        # Однієї ітерації зазвичай достатньо для low-poly ефекту
        mesh = mesh.subdivide()
    except Exception:
        pass
```

**Логіка:**
- Перевіряємо кількість вершин перед subdivision
- Якщо вершин вже багато (>10000), пропускаємо subdivision
- Однієї ітерації зазвичай достатньо для створення low-poly текстури

---

### 4. Ненадійне визначення верхніх вершин

**Місце:** `_add_strong_faceted_texture()`, рядки 297-298 (старий код)

**Проблемний код:**
```python
threshold = min_z + z_range * 0.80
top_mask = z_values > threshold
```

**Проблема:**
- На крутих схилах порівняння Z координат ненадійне
- Може визначити як "верхні" вершини, що насправді на бічних стінках

**Виправлення:**
```python
# Обчислюємо нормалі вершин
if mesh.vertex_normals is None or len(mesh.vertex_normals) != len(mesh.vertices):
    mesh.fix_normals()

# Якщо нормаль дивиться вгору (Z > 0.5), вважаємо це дахом
up_facing = mesh.vertex_normals[:, 2] > 0.5

# Fallback на Z поріг, якщо нормалі не працюють
if not np.any(up_facing):
    # ... fallback логіка ...
```

**Логіка:**
- Використовуємо нормалі вершин для визначення верхньої поверхні
- Нормаль, що дивиться вгору (Z > 0.5), вказує на верхню поверхню
- Це точніше, ніж порівняння Z координат, особливо на крутих схилах
- Fallback на Z поріг, якщо нормалі недоступні

---

## Підсумок виправлень

### До виправлення:
1. ❌ Амплітуда текстури: 500+ метрів (створює величезні шипи)
2. ❌ "Літаючий килим": весь парк піднімається, якщо одна вершина провалилась
3. ❌ Подвійний subdivision: мільйони трикутників, зависання
4. ❌ Ненадійне визначення верху: помилки на крутих схилах

### Після виправлення:
1. ✅ Амплітуда текстури: 0.25мм на моделі → правильні метри світу
2. ✅ Локальна корекція: тільки провалені вершини виштовхуються
3. ✅ Обмежений subdivision: тільки для малих мешів
4. ✅ Визначення верху через нормалі: точніше на будь-яких схилах

---

## Технічні деталі

### Розрахунок амплітуди текстури

**Формула:**
```
target_noise_mm = 0.25 мм  (бажана висота на моделі)
scale_factor = model_mm / world_m  (наприклад, 0.001 для 1:1000)
texture_amplitude = target_noise_mm / scale_factor  (метри світу)
```

**Приклад:**
- Модель: 100мм, зона: 1000м → `scale_factor = 0.1`
- `texture_amplitude = 0.25 / 0.1 = 2.5 метри` (обмежується до 2.0м)

### Локальна корекція провалення

**Алгоритм:**
```python
min_allowed_z = ground_heights + safety_margin - embed_m
new_z = np.maximum(new_z, min_allowed_z)
```

**Результат:**
- Кожна вершина порівнюється з мінімально дозволеним рівнем
- Тільки провалені вершини виштовхуються
- Інші вершини залишаються на місці

### Визначення верхніх вершин

**Метод 1 (основний):** Нормалі вершин
```python
up_facing = mesh.vertex_normals[:, 2] > 0.5
```

**Метод 2 (fallback):** Z поріг
```python
threshold = min_z + z_range * 0.80
up_facing = z_values > threshold
```

---

## Тестування

### Очікувані результати:

1. **Відсутність величезних шипів:**
   - Текстура має бути видимою, але не спотворювати геометрію
   - Амплітуда обмежена до 2 метрів

2. **Парки слідують за рельєфом:**
   - Немає "літаючих" парків
   - Парки плавно накладаються на рельєф, навіть на крутих схилах

3. **Продуктивність:**
   - Немає зависань при обробці великих парків
   - Subdivision обмежений для великих мешів

4. **Точність текстури:**
   - Текстура застосовується тільки до верхньої поверхні
   - Немає артефактів на бічних стінках

---

## Додаткові рекомендації

### Налаштування параметрів:

1. **target_noise_mm** (за замовчуванням 0.25мм):
   - Зменшити до 0.15-0.2мм для більш тонкої текстури
   - Збільшити до 0.3-0.4мм для більш видимої текстури

2. **Обмеження subdivision** (за замовчуванням 10000 вершин):
   - Зменшити до 5000 для більш агресивної оптимізації
   - Збільшити до 20000 для більш детальної текстури на великих парках

3. **Поріг нормалей** (за замовчуванням 0.5):
   - Зменшити до 0.3 для більш широкого визначення "верху"
   - Збільшити до 0.7 для більш строгого визначення

---

*Документ створено після виправлення критичних помилок в обробці зелених зон*

