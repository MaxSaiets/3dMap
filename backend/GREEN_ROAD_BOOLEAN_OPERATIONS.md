# Булеві операції: Вирізання доріг з зелених зон

## Проблема

### Z-fighting та перетин між дорогами та парками

**Симптом:**
- Дороги та парки генеруються незалежно
- Обидва "опускаються" на рельєф на однаковій висоті
- Вони перетинаються, проходять крізь одне одного
- Виглядає брудно та нереалістично

**Причина:**
- Немає булевих операцій між об'єктами
- Геометрії створюються окремо і накладаються одна на одну
- Немає фізичного розділення між зонами

---

## Рішення: Boolean Difference

### Підхід

1. **Спочатку генеруємо 2D маску всіх доріг** (об'єднаний полігон)
2. **Передаємо маску в процесор зелених зон**
3. **Вирізаємо дороги з парків** на етапі 2D геометрії (до створення 3D мешу)
4. **Результат:** Парк фізично закінчується там, де починається асфальт

---

## Реалізація

### 1. Оновлена функція `process_green_areas`

**Додано параметр:**
```python
road_polygons: Optional[object] = None  # Shapely Polygon/MultiPolygon об'єднаних доріг
```

**Логіка вирізання:**
```python
# --- ROAD CLIPPING (ВИРІЗАННЯ ДОРІГ) ---
if road_mask is not None:
    try:
        # Вирізаємо дороги з парку (Boolean Difference)
        geom = geom.difference(road_mask)
    except Exception as e:
        print(f"[WARN] Помилка вирізання доріг із парку: {e}")
        # Якщо помилка, залишаємо як є (краще мати парк, ніж нічого)
        pass
    
    # Перевіряємо, чи геометрія не стала порожньою після вирізання
    if geom is None or getattr(geom, "is_empty", False):
        continue
```

### 2. Підготовка маски доріг

**Перетворення координат:**
```python
# Переконуємось, що полігон доріг теж в локальних координатах
road_mask = road_polygons
if road_mask is not None and global_center is not None:
    # Перевірка: якщо координати доріг виглядають як UTM (великі числа)
    if abs(sample_x) > 100000:
        # Перетворюємо в локальні координати
        road_mask = transform(to_local_transform, road_mask)
```

**Важливо:**
- Обидві геометрії (парки та дороги) мають бути в одній системі координат
- Використовуємо локальні координати для узгодженості

### 3. Оновлення виклику в `main.py`

**Підготовка полігонів доріг:**
```python
# Підготовка полігонів доріг для вирізання з парків
road_polygons_for_clipping = None
try:
    # Використовуємо merged_roads_geom_local_raw (без обрізання по зоні) для контексту
    road_polygons_for_clipping = locals().get("merged_roads_geom_local_raw")
    if road_polygons_for_clipping is None:
        road_polygons_for_clipping = locals().get("merged_roads_geom_local")
    # Якщо все ще None, спробуємо створити з merged_roads_geom
    if road_polygons_for_clipping is None and merged_roads_geom is not None:
        # Перетворюємо в локальні координати
        road_polygons_for_clipping = transform(_to_local_roads, merged_roads_geom)
except Exception as e:
    print(f"[WARN] Не вдалося підготувати road_polygons для вирізання: {e}")
    road_polygons_for_clipping = None
```

**Передача в `process_green_areas`:**
```python
parks_mesh = process_green_areas(
    gdf_green,
    height_m=...,
    embed_m=...,
    terrain_provider=terrain_provider,
    global_center=None,  # already in local coords
    scale_factor=float(scale_factor),
    # --- КРИТИЧНО: Передаємо полігони доріг для вирізання ---
    road_polygons=road_polygons_for_clipping,
)
```

---

## Переваги

### 1. Ідеальний стик
- ✅ Використовуємо ту саму геометрію (`merged_roads_poly`) для створення 3D доріг і для вирізання дірок у парках
- ✅ Край парку точно повторює край дороги
- ✅ Немає перекриття або зазорів

### 2. Boundary Masking + Boolean Difference
- ✅ Boundary masking робить краї парків "плоскими" (без шуму)
- ✅ Оскільки край парку тепер — це край дороги, вони стикуються ідеально рівно
- ✅ Немає "кривих" країв на стику

### 3. Економія ресурсів
- ✅ Не генеруємо полігони під дорогами, які все одно не видно
- ✅ Менше вершин для обробки
- ✅ Швидша генерація

### 4. Візуальна якість
- ✅ Немає z-fighting
- ✅ Чітке розділення між зонами
- ✅ Реалістичний вигляд моделі

---

## Порядок операцій

### До виправлення:
```
1. Генерація доріг (3D меш)
2. Генерація парків (3D меш)
3. Накладання на рельєф (обидва окремо)
4. Результат: перекриття, z-fighting
```

### Після виправлення:
```
1. Генерація 2D полігонів доріг (merged_roads_poly)
2. Генерація 3D мешу доріг (з merged_roads_poly)
3. Вирізання доріг з парків (Boolean Difference на 2D)
4. Генерація 3D мешу парків (з вирізаними дірками)
5. Накладання на рельєф (обидва окремо, але без перекриття)
6. Результат: ідеальний стик, немає перекриття
```

---

## Обробка edge cases

### 1. Помилка вирізання
```python
try:
    geom = geom.difference(road_mask)
except Exception as e:
    # Якщо помилка, залишаємо як є (краще мати парк, ніж нічого)
    pass
```

**Чому:**
- Boolean операції можуть падати на складних геометріях
- Краще мати парк без вирізання, ніж втратити його повністю

### 2. Порожня геометрія після вирізання
```python
if geom is None or getattr(geom, "is_empty", False):
    continue
```

**Чому:**
- Якщо весь парк був вирізаний дорогами, пропускаємо його
- Це нормально для маленьких парків, повністю покритих дорогами

### 3. Дрібні артефакти
```python
# Після вирізання доріг можуть залишитися дуже маленькі шматочки
if float(getattr(poly, "area", 0.0) or 0.0) < 10.0:
    continue
```

**Чому:**
- Після вирізання можуть з'явитися дрібні шматочки (< 10м²)
- Видаляємо їх, щоб не створювати зайві меші

### 4. Перетворення координат
```python
# Перевірка: якщо координати доріг виглядають як UTM
if abs(sample_x) > 100000:
    road_mask = transform(to_local_transform, road_mask)
```

**Чому:**
- Дороги можуть бути в UTM, а парки вже в локальних координатах
- Перевіряємо та перетворюємо при потребі

---

## Технічні деталі

### Boolean Difference в Shapely

**Операція:**
```python
result = geom.difference(road_mask)
```

**Що робить:**
- Віднімає `road_mask` з `geom`
- Результат: геометрія без частин, що перетинаються з дорогами
- Підтримує Polygon, MultiPolygon, GeometryCollection

**Обмеження:**
- Може бути повільно для великих геометрій
- Може падати на невалідних геометріях (тому try/except)

### Порядок операцій

**Важливо:**
1. Вирізання доріг робиться ПЕРЕД union парків
2. Це запобігає проблемам з об'єднанням геометрій з дірками
3. Union після вирізання об'єднує вже "чисті" парки

---

## Результати

### До виправлення:
- ❌ Z-fighting між дорогами та парками
- ❌ Перетин геометрій
- ❌ Нерівні стики
- ❌ Брудний вигляд

### Після виправлення:
- ✅ Ідеальний стик між дорогами та парками
- ✅ Немає перекриття
- ✅ Чітке розділення зон
- ✅ Реалістичний вигляд моделі

---

## Тестування

### Очікувані результати:

1. **Відсутність перекриття:**
   - Парки не проходять крізь дороги
   - Дороги не проходять крізь парки
   - Чітке розділення на стику

2. **Ідеальний стик:**
   - Край парку точно повторює край дороги
   - Немає зазорів або накладання
   - Boundary masking забезпечує рівний край

3. **Продуктивність:**
   - Boolean операції не сповільнюють генерацію значно
   - Менше вершин для обробки (парки без частин під дорогами)

---

## Додаткові рекомендації

### Оптимізація продуктивності

Якщо Boolean операції повільні для великих парків:

1. **Спрощення геометрій перед вирізанням:**
   ```python
   road_mask = road_mask.simplify(0.5, preserve_topology=True)
   geom = geom.simplify(0.5, preserve_topology=True)
   geom = geom.difference(road_mask)
   ```

2. **Кешування маски доріг:**
   - Якщо обробляєте багато парків, зберігайте `road_mask` в змінній
   - Не створюйте її заново для кожного парку

3. **Обмеження розміру:**
   - Для дуже великих парків можна обрізати `road_mask` по bounds парку перед вирізанням

---

*Документ створено після додавання булевих операцій для вирізання доріг з зелених зон*

